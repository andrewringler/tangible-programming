<!DOCTYPE html>
<html lang="en">
  <head>
    <title>MacroScope</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
        background: 0x000000;
        overflow: hidden;
      }
      #overlay {
          position: absolute;
          left: 140px; top: 90px;
          font-family: Helvetica, Arial, sans-serif;
          z-index: 1000;
      }
      #title {
          position: relative;
          text-align: center;
          left: 0px; top:0px;
          color: #ffffff;
          font-size: 108px;
      }
      #authors {
          position: relative;
          text-align: center;
          left: 0px; top:0px;
          font-family: Helvetica, Arial, sans-serif;
          color: #dddddd;
          font-size: 18px;
      }
      #description {
          position: relative;
          left: 0px; top:40px;
          width: 800px;
          color: #333333;
          font-size: 16px;
      }
      #instructions {
          position: relative;
          left: 0px; top:70px;
          width: 800px;
          color: #333333;
          font-size: 16px;
      }
      #container {
        background:0x000000;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
      img.icon {
         width : 155px;
      }
    </style>
  </head>
  <body>
    <div id = "overlay">
        <div id="title">MacroScope</div>
        <div id="authors">Xiao Xiao, Donald Derek, Penny Webb, Daniel Fitzgerald, and Hiroshi Ishii</div>
        <div id="description">
            <p>
            Ici est l'espace pour une petite description de ce projet. Je vous raconte une histoire immense. C'est une histoire d'une guerre effrayante entre le monde physical et le monde digital. Au debut de la 21ere siecle, les peuples de la terre sont devenus esclaves du monde digital, l'empire des pixels. Un professeur japonais de MIT a decide de lutter contre l'empire. Donc il a commence une guerre contre les pixels. A la fin le monde physique a gagne. les citoyens digitels ne sont pas detruits. Par contre, ils servissent toujours le monde physique..."
            </p>
        </div>
        <div id="instructions">
            <table border=0 width='100%'>
                <tr>
                    <td><img class="icon" src="assets/icon1.png"></td>
                    <td><img class="icon" src="assets/icon2.png"></td>
                    <td><img class="icon" src="assets/icon3.png"></td>
                    <td><img class="icon" src="assets/icon4.png"></td>
                </tr>
            </table>
        </div>

    </div>
    <div id="container"></div>
    <script type="x-shader/x-vertex" id="vertexShader">
        varying vec3 vWorldPosition;
        void main() {
            vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
            vWorldPosition = worldPosition.xyz;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShader">
        uniform vec3 topColor;
        uniform vec3 bottomColor;
        uniform float offset;
        uniform float exponent;
        varying vec3 vWorldPosition;
        void main() {
            float h = normalize(vWorldPosition + offset).y;
            gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
        }
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r72/three.min.js"></script>
  <script src="js/StereoEffect.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/stats.min.js"></script>
  <script src="js/dat.gui.min.js"></script>
  <script src="js/sockets.utils.js"></script>
  <script src="js/loaders/MTLLoader.js"></script>
  <script src="js/loaders/OBJMTLLoader.js"></script>
  <script src="js/tween.js"></script>
  <script src="js/geometry/World.js"></script>
  <script src="js/geometry/ShapeDisplay.js"></script>
  <script src="js/geometry/InputHandler.js"></script>

  <script>
    var camera, scene, renderer;
    var effect, controls;
    var element, container;
    var bSetCameraRotation = false;

    var clock = new THREE.Clock();
    var stats;
    var controlVars;

    var e14;
    var xForm, xFormMini;
    var xFormCenter, xFormLeft, xFormRight;
    var xFormFrontLeft, xFormFrontRight;
    var player;
    var pp; // ping pong table :-D

    var socket;
    var inputManager = new InputManager();
    var device = false;
    var eul;

    init();
    animate();

    function init() {

        setupSocket();      //Init the Websocket
        setupRendering();   // Make the renderer and stereo effect
        setupScene();       // Scene + Shape Display!
        setupLights();      // Lights and shaders

        camera = new THREE.PerspectiveCamera(90, 1, 0.001, 5000);
        //camera.position.set(0, 17, 0);
        camera.position.set(0, 3, 0);
        camera.rotation.y = -Math.PI/2;

        player = new Player(camera);
        player.mesh.position.set(-10, 28.3, 0);

        // Virtual objects
        //----------------------------------------------------------------------
        loadPiano();
        e14.addItem(new Item('piano', 0, 1, 1, 1));

        xFormMini = createMiniCooperForm();
        e14.addItem(new Item('xFormMini', 0, 2, 0, 1, 1));
        e14.addShapeDisplay(xFormMini, 0, 24);

        pp = createPingPongTable();
        e14.addItem(new Item('pingPong', 2, 3, 1, 1, 1));

        // Insert map: load it as image!
        //----------------------------------------------------------------------
        loadImages("assets/ML", 1);
        function loadImages(path, n) {
            if (n == 0) {
                e14.loadCurrentLevelForAllDisplays(true, true);
                inputManager.lastSendHeightsTime = performance.now();
                socket.send("P"+xFormMini.getHeightsMsgForPhysical());
                return;
            }
            var img = new Image();
            img.src = path + n + ".png";
            img.onload = function() {
                e14.addLevel(img, 63, 82);
                loadImages(path, n-1);
            }
        }

        // Peripheral stuff: stats, control GUI
        //----------------------------------------------------------------------
        window.addEventListener('resize', resize, false);
        setTimeout(resize, 1);

        // create the stats
        stats = createStats();
        document.body.appendChild(stats.domElement);

        // control variables
        controlVars = new function () {
            this.stereo = false;
            this.stats = false;
            this.cubeX = 20;
            this.cubeY = 0;
            this.cubeZ = 0;
            this.mapZ = 0;
        };
        addControls(controlVars);
    }

    // Helpful Helper Functions
    //--------------------------------------------------------------------------
    function setupSocket() {
        console.log('Setup Socket');
        socket = new WebSocket( get_appropriate_ws_url());

        try {
            socket.onopen = function() {
                console.log("Websocket connection OPEN");
            }
            socket.onmessage = function got_packet(msg) {
                //console.log("message");
                handleMsg(msg.data);
            }
            socket.onclose = function() {
                console.log("websocket connection CLOSED");
            }
        } catch (exception) {
            console.log("Something went wrong " + exception);
        }
    }

    var shadowThresh = 0;
    var reloadModel = 2;
    function handleMsg(msg) {
        type = msg[0];
        content = msg.slice(1);
        pins = content.split("-");

        // FOR MESSAGE FROM PHYSICAL SHAPE DISPLAY
        if (type == "T") {
            touchHandler = inputManager.initTouchHandler(pins, xForm.xWidth, xForm.yWidth);
            if (touchHandler)
                inputManager.reactToTouchInput(touchHandler);
        }
        if(type == "R"){
            //console.log(content)
            var q = JSON.parse(content);

            var quat = new THREE.Quaternion(q._x, q._y, q._z, q._w);
            eul = new THREE.Euler().setFromQuaternion(quat, 'XYZ');
        }
    }

    function setupRendering() {
        renderer = new THREE.WebGLRenderer();
        element = renderer.domElement;
        container = document.getElementById('container');
        container.appendChild(element);

        effect = new THREE.StereoEffect(renderer);
    }

    function setupScene() {
        scene = new THREE.Scene();

        // The important stuff: Shape Display stuff
        e14 = new World(27, -2);

        xForm = new ShapeDisplay(24, 24, 12, scene);
        xForm.container.position.x = 16;
        xForm.container.name = "xForm";
        e14.addShapeDisplay(xForm, 0, 24);
        xForm.container.visible = false;

        xFormCenter = new ShapeDisplay(24, 24, 12, scene);
        xFormCenter.container.position.x = 40;
        xFormCenter.container.name = "xFormCenter";
        e14.addShapeDisplay(xFormCenter, 0, 0);

        xFormLeft = new ShapeDisplay(24, 24, 12, scene);
        xFormLeft.container.position.x = 40;
        xFormLeft.container.position.z = - xFormCenter.xWidth * 1.5;
        xFormLeft.container.name = "xFormLeft";
        e14.addShapeDisplay(xFormLeft, -24, 0);

        xFormRight = new ShapeDisplay(24, 24, 12, scene);
        xFormRight.container.position.x = 40;
        xFormRight.container.position.z = xFormCenter.xWidth * 0.5;
        xFormRight.container.name = "xFormRight";
        e14.addShapeDisplay(xFormRight, 24, 0);

        xFormFrontLeft = new ShapeDisplay(24, 24, 12, scene);
        xFormFrontLeft.container.position.z = - xFormCenter.xWidth * 1.5;
        xFormFrontLeft.container.position.x = 16;
        xFormFrontLeft.container.name = "xFormFrontLeft";
        e14.addShapeDisplay(xFormFrontLeft, -24, 24);

        xFormFrontRight = new ShapeDisplay(24, 24, 12, scene);
        xFormFrontRight.container.position.x = 16;
        xFormFrontRight.container.position.z = xFormCenter.xWidth * 0.5;
        xFormFrontRight.container.name = "xFormRight";
        e14.addShapeDisplay(xFormFrontRight, 24, 24);

        // Placeholder object for orientation
        var cube = new THREE.Mesh(  new THREE.BoxGeometry(1, 1, 1),
                                    new THREE.MeshLambertMaterial({ color: 'red' }) );
        cube.name = 'cube';
        scene.add(cube);

        // Floor
        var texture = THREE.ImageUtils.loadTexture('assets/grid.png');
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat = new THREE.Vector2(20, 20);
        texture.anisotropy = renderer.getMaxAnisotropy();

        var material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            specular: 0xffffff,
            shininess: 20,
            shading: THREE.FlatShading,
            map: texture
        });

        var geometry = new THREE.PlaneBufferGeometry(1000, 1000);
        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = -40;
        mesh.rotation.x = -Math.PI / 2;
        scene.add(mesh);
    }

    function setupLights() {
        // Lights
        //----------------------------------------------------------------------
        var hemiLight = new THREE.HemisphereLight( 0x999999, 0xffffff, 1);
        hemiLight.position.y = 500;
        scene.add(hemiLight);


        var directionalLight = new THREE.DirectionalLight();
        directionalLight.position.copy(new THREE.Vector3(-5000, 30, 0));
        scene.add(directionalLight);

        // Mighty Skydome
        // //----------------------------------------------------------------------
        var vertexShader = document.getElementById( 'vertexShader' ).textContent;
        var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
        var uniforms = {
            topColor: 	 { type: "c", value: new THREE.Color( 0x000000 ) },
            bottomColor: { type: "c", value: new THREE.Color( 0x000000 ) },
            offset:		 { type: "f", value: 400 },
            exponent:	 { type: "f", value: 0.6 }
        };
        uniforms.topColor.value.copy( hemiLight.color );

        var skyGeo = new THREE.SphereGeometry( 1000, 32, 15 );
        var skyMat = new THREE.ShaderMaterial( {
            uniforms: uniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            side: THREE.BackSide
        } );

        var sky = new THREE.Mesh( skyGeo, skyMat );
        scene.add( sky );

    }

    function createStats() {
        var stats = new Stats();
        stats.setMode(0);

        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';
        stats.domElement.style.opacity = 0;

        return stats;
    }

    function addControls(controlObject) {
        var gui = new dat.GUI();
        gui.add(controlObject, 'stereo');
        gui.add(controlObject, 'cubeX', 0, 30);
        gui.add(controlObject, 'cubeY', 0, 20);
        gui.add(controlObject, 'cubeZ', -15, 15);
        gui.add(controlObject, 'mapZ', -15, 15);
        gui.add(controlObject, 'stats', false).onFinishChange(function() {
            if (controlObject.stats)
                stats.domElement.style.opacity = 0.9;
            else
                stats.domElement.style.opacity = 0;
        });
        gui.close();
    }

    function resize() {
      var width = container.offsetWidth;
      var height = container.offsetHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      renderer.setSize(width, height);
      effect.setSize(width, height);
    }

    // Rendering!
    //--------------------------------------------------------------------------
    function update(dt) {
        resize();

        camera.updateProjectionMatrix();

        // if avatar mode... rotate Camera
        if(bSetCameraRotation && player.inAvatarView()){
            camera.rotation.x = eul._x;
            camera.rotation.y = eul._y;
            camera.rotation.z = eul._z;
        }

        scene.getObjectByName('cube').position.x = controlVars.cubeX;
        scene.getObjectByName('cube').position.y = controlVars.cubeY;
        scene.getObjectByName('cube').position.z = controlVars.cubeZ;

        if (pp.visible)
            pp.update(dt);
        TWEEN.update();

        stats.update();


    }

    function render(dt) {
      controlVars.stereo ? effect.render(scene, camera) : renderer.render(scene, camera);
    }

    function animate(t) {
      requestAnimationFrame(animate);

      update(clock.getDelta());
      render(clock.getDelta());
    }

    function fullscreen() {
      if (container.requestFullscreen) {
        container.requestFullscreen();
      } else if (container.msRequestFullscreen) {
        container.msRequestFullscreen();
      } else if (container.mozRequestFullScreen) {
        container.mozRequestFullScreen();
      } else if (container.webkitRequestFullscreen) {
        container.webkitRequestFullscreen();
      }
    }

    window.addEventListener('keydown', function(e) {
        console.log("key presed ", e.keyCode);
        var sendOrigin = false;
        var setHeights = false;
        switch(e.keyCode) {
            case 37:
            case 100:   // numpad 6
                e14.origin.x ++;
                setHeights = true;
            break;
            case 39:
            case 102:   // numpad 4
                e14.origin.x --;
                setHeights = true;
            break;
            case 38:
            case 104:   // numpad 8
                e14.origin.y ++;
                setHeights = true;
            break;
            case 40:
            case 98:   // numpad 5
                e14.origin.y --;
                setHeights = true;
            break;
            case 87: // W
                player.moveToSquare(player.row, player.col - 1, xForm);
                sendOrigin = true;
            break;
            case 83: // S
                player.moveToSquare(player.row, player.col + 1, xForm);
                sendOrigin = true;
            break;
            case 68: // D
                player.moveToSquare(player.row + 1, player.col , xForm);
                sendOrigin = true;
            break;
            case 65: // A
                player.moveToSquare(player.row - 1, player.col, xForm);
                sendOrigin = true;
            break;
            case 13:    // Enter
                // e14.runFunctionForUnit(e14.origin.x + player.row, e14.origin.y + player.col, xForm);
                bSetCameraRotation = !bSetCameraRotation;
                if (!bSetCameraRotation)
                    player.resetCameraOrientation();
            break;
            case 32:    // Space
            case 101:   // numpad 5
                player.goToBkgView();
                socket.send("VM");
                break;
        }
        if (setHeights) {
            console.log("SEND HEIGHTS TO PHYSICAL");
            e14.loadCurrentLevelForAllDisplays(true, true);
            inputManager.lastSendHeightsTime = performance.now();
            socket.send("O"+ e14.origin.x +","+e14.origin.y);
            console.log("ORIGIN ", e14.origin.x, e14.origin.y);
            socket.send("P"+xFormMini.getHeightsMsgForPhysical());
        }


    });

  </script>
  </body>
</html>
