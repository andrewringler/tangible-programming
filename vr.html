<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Connecting up Google Cardboard to web APIs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
        overflow: hidden;
      }
      #webglviewer {
        bottom: 0;
        left: 0;
        position: absolute;
        right: 0;
        top: 0;
      }
      
      
    </style>
  </head>
  <body>
    <div id="webglviewer"></div>
    
    <script src="./js/three.min.js"></script>
    <script src="./js/StereoEffect.js"></script>
    <script src="./js/DeviceOrientationControls.js"></script>
    <script src="./js/OrbitControls.js"></script>
    <script src="./js/ShapeDisplay.js"></script>
    <script src="./js/helvetiker_regular.typeface.js"></script>
    <script src="https://timezonedb.googlecode.com/files/timezonedb.js" type="text/javascript"></script>
    <script>
      var scene,
          camera,
          renderer,
          element,
          container,
          effect,
          controls,
          clock;

      var shapeDisplay;

      var shape1 = [];
      var shape2 = [];
      var sec;
      var dHeightPerSec=[];
      var period=10;
      var cnt=0;

      init();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.001, 700);
        camera.position.set(0, 15, 0);
        scene.add(camera);

        renderer = new THREE.WebGLRenderer();
        element = renderer.domElement;
        container = document.getElementById('webglviewer');
        container.appendChild(element);

        effect = new THREE.StereoEffect(renderer);

        // Our initial control fallback with mouse/touch events in case DeviceOrientation is not enabled
        controls = new THREE.OrbitControls(camera, element);
        controls.target.set(
          camera.position.x + 0.15,
          camera.position.y,
          camera.position.z
        );
        controls.noPan = true;
        controls.noZoom = true;

        // Our preferred controls via DeviceOrientation
        function setOrientationControls(e) {
          if (!e.alpha) {
            return;
          }

          controls = new THREE.DeviceOrientationControls(camera, true);
          controls.connect();
          controls.update();

          element.addEventListener('click', fullscreen, false);

          window.removeEventListener('deviceorientation', setOrientationControls, true);
        }
        window.addEventListener('deviceorientation', setOrientationControls, true);

        // Lighting
        var light = new THREE.PointLight(0x999999, 2, 100);
        light.position.set(50, 60, 50);
        scene.add(light);

        var lightScene = new THREE.PointLight(0xABA592, 2, 100);
        lightScene.position.set(0, 10, 0);
        scene.add(lightScene);
        
        var lightScene2 = new THREE.PointLight(0x606060, 2, 100);
        lightScene2.position.set(0, 30, -30);
        scene.add(lightScene2);

        var floorTexture = THREE.ImageUtils.loadTexture('textures/wood.jpg');
        floorTexture.wrapS = THREE.RepeatWrapping;
        floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat = new THREE.Vector2(50, 50);
        floorTexture.anisotropy = renderer.getMaxAnisotropy();

        var floorMaterial = new THREE.MeshPhongMaterial({
          color: 0xffffff,
          specular: 0xffffff,
          shininess: 20,
          shading: THREE.FlatShading,
          map: floorTexture
        });

        var geometry = new THREE.PlaneBufferGeometry(1000, 1000);

        var floor = new THREE.Mesh(geometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        initShapeDisplay();

        clock = new THREE.Clock();

        shape1=new2DArray();
        shape2=new2DArray();
        for (var i = 10; i < 21; i++)
            shape1[10][i]=(i-10)/3;
        //shape1[10][10]=1;
        for (var i = 10; i < 21; i++)
            shape2[10][30-i]=(i-10)/3;
        //shape2[10][10]=5;
        initMotionFromShape(shape1,shape2);

        animate();
      }

      var sqrt, maxDistance;
      var normalizedPhase = 0;
      var speed = 0.03;
      var crests = 3.5;
      var distanceScalar = Math.PI * (crests * 2 - 1) / maxDistance;
      var distanceOffset = 2 * Math.PI;
      var maxAmplitude = 0.15;
      var heightScalar = 3.00 / (2 * maxAmplitude);
      var heightOffset = -0.9;


      function initShapeDisplay() {
          shapeDisplay = new ShapeDisplay(30, 30, 10, scene);
          shapeDisplay.setPosition(5, -5);

          var centerX = 15;
          var centerY = 15;
          maxDistance = Math.sqrt( (centerX-0)*(centerX-0) + (centerY-0)*(centerY-0) );

          sqrt = [];
          for (var x = 0; x < 30; x++) {
              for (var y = 0; y < 30; y++) {
                  sqrt[x*30 + y] = Math.sqrt( (centerX-x)*(centerX-x) + (centerY-y)*(centerY-y) );
              }
          }
      }



      function animate() {
        requestAnimationFrame(animate);

        //updateDisplay();

        updateMotionFromShape(shape1,shape2);
        update(clock.getDelta());
        effect.render(scene, camera);
      }

      function resize() {
        var width = container.offsetWidth;
        var height = container.offsetHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        effect.setSize(width, height);
      }

      function update(dt) {
        resize();

        camera.updateProjectionMatrix();
        controls.update(dt);
      }

      function updateDisplay() {

          // Didn't use this
          var frequency = 0.5;

          normalizedPhase += speed;
          var phase = 2 * Math.PI * normalizedPhase;

          
          /*for (var x = 0; x < shapeDisplay.xWidth; x++) {
             for (var y = 0; y < shapeDisplay.yWidth; y++) {
                  var d = sqrt[x*30 + y];
                  distance = distanceScalar * d + distanceOffset;
                  var height = Math.sin(distance - phase) / distance;
                  shapeDisplay.setPinHeight(x, y, heightScalar * height + heightOffset);
             }
         }*/
         
          arr=new2DArray();
          arr[0][0]=5;
          arr[10][20]=3;
          //setShapeByArray(arr);
      }

      function new2DArray(){

          // Create and init 2D array

          var arr=[];
          for (var i = 0; i < 30 ; i++) {
              arr[i]=[];
          }

          for (var x = 0; x < 30 ; x++) {
              for (var y = 0; y < 30; y++){
                  arr[x][y] = 0;
              }
          }
          return arr;
      }

      function setShapeByArray(arr) {

        // Set shape of Formation by using array of height of each pin
        
        for (var x = 0; x < 30 ; x++) {
            for (var y = 0; y < 30; y++) {
                shapeDisplay.setPinHeight(x, y, arr[x][y]);
            }
        }
      }

      function initMotionFromShape(s1, s2) {

          // Set high change for each time step

          setShapeByArray(s1);
          dHeightPerSec=new2DArray();
          for (var x = 0; x < 30 ; x++) {
              for (var y = 0; y < 30; y++) {
                  dHeightPerSec[x][y] = (Number(s2[x][y])-Number(s1[x][y]))/Number(period);
              }
          }
      }

      function updateMotionFromShape(s1, s2) {

          // USE this instead of updateDisplay

          // Condition of each update will be per sec
          var time = new Date();

          if(cnt==0){
              sec=time.getSeconds();
          }

          sec2=time.getSeconds();

          // Condition to update every second not milli
          if(Number(sec)==Number(sec2)&&cnt!=0) {
              return ;
          }

          sec = sec2;
          if(cnt==period) // finish task from changing from shape 1 to 2
              return;

          // Update new shape with s3 array
          var s3 = [];
          s3=new2DArray();
          for (var x = 0; x < 30 ; x++) {
              for (var y = 0; y < 30; y++) {
                  s3[x][y] = shapeDisplay.getPinHeight(x,y)-10+dHeightPerSec[x][y];
              }
          }
          console.log(s3[10][10])
          setShapeByArray( s3 );

          // Count the step of update
          cnt++;

          // Set current shape
          for (var x = 0; x < 30 ; x++) {
              for (var y = 0; y < 30; y++) {
                  shape1[x][y] = shapeDisplay.getPinHeight(x,y);
              }
          }

      }

      function fullscreen() {
        if (container.requestFullscreen) {
          container.requestFullscreen();
        } else if (container.msRequestFullscreen) {
          container.msRequestFullscreen();
        } else if (container.mozRequestFullScreen) {
          container.mozRequestFullScreen();
        } else if (container.webkitRequestFullscreen) {
          container.webkitRequestFullscreen();
        }
      }

      function getURL(url, callback) {
        var xmlhttp = new XMLHttpRequest();

        xmlhttp.onreadystatechange = function() {
          if (xmlhttp.readyState == 4) {
             if (xmlhttp.status == 200){
                 callback(JSON.parse(xmlhttp.responseText));
             }
             else {
                 console.log('We had an error, status code: ', xmlhttp.status);
             }
          }
        }

        xmlhttp.open('GET', url, true);
        xmlhttp.send();
      }
    </script>
  </body>
</html>
